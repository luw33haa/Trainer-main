<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Button?>
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.Pane?>
<?import javafx.scene.text.Font?>

<Pane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="780.0" prefWidth="1300.0" style="-fx-background-color: #FFE4B5;" xmlns="http://javafx.com/javafx/21" xmlns:fx="http://javafx.com/fxml/1" fx:controller="com.company.Main">
    <children>
        <TextField editable="false" layoutX="532.0" layoutY="14.0" prefHeight="50.0" prefWidth="474.0" style="-fx-background-color: transperent;" text="6.Выберите код с правильно использованными Переменной Char">
            <font>
                <Font size="15.0" />
            </font>
        </TextField>
        <Button alignment="TOP_CENTER" layoutX="511.0" layoutY="85.0" mnemonicParsing="false" onAction="#lvl266" prefHeight="241.0" prefWidth="506.0" style="-fx-background-color: #F0F8FF;" text="public String input() throws MyException {//предупреждаем с помощью throws,&#10;&#10;// что метод может выбросить исключение MyException&#10;      BufferedReader reader = new BufferedReader(new &#10;InputStreamReader(System.in));&#10;&#10;    String s = null;&#10;&#10;//в блок try заключаем код, в котором может произойти исключение, в данном&#10;// случае компилятор нам подсказывает, что метод readLine() класса&#10;// BufferedReader может выбросить исключение ввода/вывода&#10;&#10;    try {&#10;        s = reader.readLine();&#10;// в блок  catch заключаем код по обработке исключения IOException&#10;    } catch (IOException e) {&#10;        System.out.println(e.getMessage());">
            <font>
                <Font size="13.0" />
            </font></Button>
        <Button layoutX="511.0" layoutY="355.0" mnemonicParsing="false" onAction="#lvl2666" prefHeight="241.0" prefWidth="506.0" style="-fx-background-color: #F0F8FF;" text=" public static void main(String[] args) {&#10;        Print print = new Print();&#10;        List list= Arrays.asList(&quot;first step&quot;, null, &quot;second step&quot;);&#10;&#10;        for (String s:list) {&#10;            catch  {&#10;                print.print(s);&#10;            }&#10;            try  (NullPointerException e) {&#10;                System.out.println(e.getMessage());&#10;                System.out.println(&quot;Exception was processed. Program continues&quot;);&#10;            }&#10;        &#10;&#10;    }&#10;&#10;    }">
            <font>
                <Font size="13.0" />
            </font></Button>
        <TextArea layoutX="10.0" layoutY="10.0" prefHeight="750.0" prefWidth="490.0" text="Нередко в процессе выполнения программы могут возникать ошибки,&#10; при том необязательно по &#10;вине разработчика. Некоторые из них трудно предусмотреть или предвидеть,&#10; а иногда и вовсе &#10;невозможно. Так, например, может неожиданно оборваться сетевое&#10; подключение при передаче &#10;файла. Подобные ситуации называютсяисключениями.&#10;В языке Java предусмотрены специальные средства для обработки&#10; подобных ситуаций. Одним из &#10;таких средств является конструкцияtry...catch...finally. При возникновении&#10; исключения в блоке try &#10;управление переходит в блок catch, который может обработать данное &#10;исключение. Если такого &#10;блока не найдено, то пользователю отображается сообщение о &#10;необработанном исключении, а &#10;дальнейшее выполнение программы останавливается. И чтобы &#10;подобной остановки не произошло, &#10;и надо использовать блок try..catch. Например:&#10;&#9;int[] numbers = new int[3];&#10;numbers[4]=45;&#10;System.out.println(numbers[4]);&#10;Так как у нас массив numbers может содержать только 3 элемента,&#10; то при выполнении &#10;инструкцииnumbers[4]=45консоль отобразит исключение,&#10; и выполнение программы будет &#10;завершено. Теперь попробуем обработать это исключение:&#10;&#9;try{&#10;int[] numbers = new int[3];&#10;numbers[4]=45;&#10;System.out.println(numbers[4]);&#10;}&#10;catch(Exception ex){&#10;&#10;ex.printStackTrace();&#10;}&#10;System.out.println(&quot;Программа завершена&quot;);&#10;При использовании блокаtry...catchвначале выполняются&#10; все инструкции между операторами try &#10;и catch. Если в блоке try вдруг возникает исключение, &#10;то обычный порядок выполнения &#10;останавливается и переходит к инструкции сatch.&#10; Поэтому когда выполнение программы дойдет &#10;до строкиnumbers[4]=45;, программа остановится и перейдет к блокуcatch&#10;Выражениеcatchимеет следующий синтаксис:catch (тип_исключения &#10;имя_переменной). В данном случае объявляется переменнаяex,&#10; которая имеет &#10;типException. Но если возникшее исключение не является&#10; исключением типа, указанного в &#10;инструкции сatch, то оно не обрабатывается, а программа&#10; просто зависает или выбрасывает &#10;сообщение об ошибке.&#10;Но так как типExceptionявляется базовым классом&#10; для всех исключений, то выражениеcatch &#10;(Exception ex)будет обрабатывать практически &#10;все исключения. Обработка же исключения в &#10;данном случае сводится к выводу на консоль &#10;стека трассировки ошибки с помощью &#10;методаprintStackTrace(), определенного в классе Exception.&#10;После завершения выполнения блока catch &#10;программа продолжает свою работу, выполняя все &#10;остальные инструкции после блока catch.&#10;Конструкция try..catch также может иметь&#10; блокfinally. Однако этот блок необязательный, и его &#10;можно при обработке исключений опускать.&#10; Блокfinallyвыполняется в любом случае, &#10;возникло ли исключение в блоке try или нет:&#10;&#9;try{&#10;int[] numbers = new int[3];&#10;numbers[4]=45;&#10;System.out.println(numbers[4]);&#10;}&#10;catch(Exception ex){&#10;ex.printStackTrace();&#10;}&#10;finally{&#10;System.out.println(&quot;Блок finally&quot;);&#10;}&#10;System.out.println(&quot;Программа завершена&quot;);" />
    </children>
</Pane>
